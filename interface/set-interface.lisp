;;; -*- Mode: Lisp ; Base: 10 ; Syntax: ANSI-Common-Lisp -*-
;;;;; mapping of keys to values -- part common to pure and stateful

#+xcvb (module (:depends-on ("interface/map-interface")))

(in-package :interface)

(define-interface <set*> (<finite-collection>) ()
  (:abstract)
  (:method> value-interface () <boolean>)
  (:generic> member-p (element set*) (:in 2) (:values foundp)
   (:documentation "Is a given object member of the set?"))
  (:generic> member-count (element set*) (:in 2) (:values foundp)
   (:documentation "How many times for the element appear in the set*?"))
  (:generic> set-list (set) (:in 1) (:values list)
   (:documentation "Convert a set of given interface to a list"))
  (:generic> list-set (list) (:values map) (:out 0)
   (:documentation "Convert a list to a set of given interface")))

(define-interface <set> (<set*> <foldable-*-from>) () ;; a set is a map from the key interface to boolean
  (:abstract)
  (:method> value-interface () <boolean>)
  (:method> member-count (element set) (boolean-integer (member-p element set))))

(define-interface <multiset> (<set*> <map-foldable-from-*>) () ;; a multiset is a map from the key interface to (positive) integer
  (:abstract)
  (:method> value-interface () <integer>)
  (:method> member-p (element multiset) (plusp (member-count element set)))
  (:generic> multiset-list (set) (:in 1) (:values list)
   (:documentation "Convert a multiset of given interface to a list"))
  (:generic> list-multiset (list) (:values map) (:out 0)
   (:documentation "Convert a list to a multiset of given interface")))

(defun cons--t (x) (cons x t))
(defun cons--1 (x) (cons x 1))

(define-interface <set*-from-collection> (<set*>)
  ((base-interface :type <map> :initarg :base-interface :reader base-interface))
  (:method key-interface (<i>) (key-interface (base-interface <i>)))
  (:method empty (<i>) (empty (base-interface <i>)))
  (:method empty-p (<i> x) (empty-p (base-interface <i>) x)))

(define-interface <set-from-map> (<set> <set*-from-collection>) ()
  (:parametric (base-interface)
    (make-interface :base-interface base-interface))
  (:method member-p (<i> element set)
    (nth-value 1 (lookup (base-interface <i>) set element)))
  (:method for-each (<i> set f)
    (for-each* (base-interface <i>) #'(lambda (k v) v (funcall f k))))
  (:method for-left (<i> set f seed)
    (for-left* (base-interface <i>) #'(lambda (a k v) v (funcall f a k)) seed))
  (:method for-right (<i> set f seed)
    (for-right* (base-interface <i>) #'(lambda (k v a) v (funcall f k a)) seed))
  (:method set-list (<i> set)
    (mapcar 'car (map-alist (base-interface <i>) set)))
  (:method list-set (<i> list)
    (alist-map (base-interface <i>) (mapcar #'cons--t list)))
  (:method size (<i> x)
    (size (base-interface <i>) x)))

(define-interface <multiset-from-map> (<multiset> <set*-from-collection>)
  ((base-interface :type <map> :initarg :base-interface :reader base-interface))
  (:parametric (base-interface)
     (make-interface :base-interface base-interface))
  (:method member-count (<i> element set)
     (or (lookup (base-interface <i>) set element) 0))
  (:method for-each* (<i> set f)
     (for-each* (base-interface <i>) f))
  (:method for-left* (<i> set f seed)
     (for-left* (base-interface <i>) f seed))
  (:method for-right* (<i> set f seed)
     (for-right* (base-interface <i>) f seed))
  (:method multiset-list (<i> multiset)
     (fold-right*
      (base-interface <i>) set
      #'(lambda (k v m)
	  (append (make-list v :initial-element k) m))))
  (:method size (<i> x)
    (monoid-fold (base-interface <i>) <integer> x (constantly 1))))

(define-interface <set-from-multiset> (<set-from-map>) ()
  (:parametric (base-interface)
    (make-interface :base-interface base-interface))
  (:method member-p (<i> element set)
    (member-p (base-interface <i>) element set)))

(define-interface <multiset-from-set> (<multiset> <set*-from-collection>)
  ((base-interface :type <map> :initarg :base-interface :reader base-interface))
  (:parametric (base-interface)
     (make-interface :base-interface base-interface))
  (:method member-count (<i> element set)
     (boolean-integer (member-p (base-interface <i>) element set)))
  (:method for-each* (<i> set f)
     (for-each (base-interface <i>) (compose f #'cons--1)))
  (:method for-left* (<i> set f seed)
     (for-left (base-interface <i>) #'(lambda (a x) (f a x 1)) seed))
  (:method for-right* (<i> set f seed)
     (for-right* (base-interface <i>) #'(lambda (x a) (f x 1 a)) seed))
  (:method multiset-list (<i> multiset)
     (set-list (base-interface <i>) set))
  (:method size (<i> x)
    (size (base-interface <i>) x)))
