;;;;-*- Lisp -*-
#|
* oconnore:
** migrate ds.scrbl from exscribe to racket's scribble with acm alternate style (ask jonrafkind on #racket)
** review abstract
** implement Red-Black trees?
** implement arrays -- use RRB-trees? http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf
** [[adopt same names as cl-containers?]]

* fare:
** test explicit -> explicit adapters
*** Remember functions that were built with explicit->implicit adapter,
  and optimize away indirection through interface in any implicit->explicit transformation back.

** write pure <-> impure adapters
  Provide wrappers for all relevant methods via macros.
  Also need to identify for every method
  which position in argument and/or return values
  holds the object or datum to wrap/unwrap.
  mutating
  linearized

** write detached <-> subjective adapters
*** subjective interfaces (=regular OO) vs separate interfaces.

** update abstract
** look at how scala does these things http://www.scala-lang.org/

** Move the payload of a tree out of the basic tree structure (i.e. (key, value))
** Add drop and insert side chooser as a method.
** Add value merging as a method
** Get something like cl-container's find-or-create-class, combined with memoization,
  for generating classes that match some specification of an interface.
** Note that a single interface may have many classes and sub-interfaces,
  sometimes with mutual recursion in classes pointing to each other
  through methods and/or :class allocated slots.


** Develop example of multiply-indexed-organized tuple store.
  Each node is simultaneously node of multiple trees.
  Depending on which index you're using,
  they have to be viewed as a tree in the according way,
  and appropriate accessors have to be chosen for say subtree access.
  The same tree-manipulation routines can be used on the same tree nodes
  with completely different results depending on which interface you use.

objectification can be done in a generic way with a parameterized class
objectify-interface with two slots: the interface and the object.

|#

(in-package :pure)

(define-interface <linearized> ()
  ((stateful-interface
    :reader stateful-interface
    :initarg :stateful-interface)
   (box-interface
    :reader box-interface
    :initarg :box-interface :initform <one-use-value-box>))
  (:parametric (interface &optional unsafe)
    (make-interface :stateful-interface interface
                    :box-interface (if unsafe <value-box> <one-use-value-box>))))

(define-interface linearized-map (<map> <linearized>)
  ()
  (:parametric (interface &optional unsafe)
    (make-interface :stateful-interface interface
                    :box-interface (if unsafe <value-box> <one-use-value-box>))))

(defmethod lookup ((i linearized-map) map key)
  (lookup (stateful-interface i) (box-value map) key))

(defmethod insert ((i linearized-map) map key value)
  (let ((map-object (unbox (box-interface i) map)))
    (multiple-value-bind ()
        (stateful:insert (stateful-interface i) map-object key value)
      (values (make-box (box-interface i) :value map-object)))))

(defun linearize-map-interface (stateful-map-interface &optional unsafe)
  (<linearize>
    method pure:convert ((l linearized-map) (s stateful-map) m)
  (make-box (box-interface l) :value m))


(in-package :stateful)

(symbol-macrolet
   ((s (stateful-interface i))
    (p (pure-interface i)))

pure:empty-table p

